### Linux文件基本属性

```
dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot
```

在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。

- 当为 **d** 则是目录
- 当为 **-** 则是文件；
- 若是 **l** 则表示为链接文档(link file)；
- 若是 **b** 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
- 若是 **c** 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。

接下来的字符中，以三个为一组，且均为 **rwx** 的三个参数的组合。其中， **r** 代表可读(read)、 **w** 代表可写(write)、 **x** 代表可执行(execute)

#### 更改文件属性

##### chgrp：更改文件属组

```bash
chgrp [-R] 属组名 文件名
```

-R：递归更改文件属组

##### chown：更改文件属主，也可以同时更改文件属组

```bash
chown [–R] 属主名 文件名
chown [-R] 属主名：属组名 文件名
```

##### 更改文件9个属性

```
chmod [-R] xyz 文件或目录
```

##### 符号类型改变文件权限

我们可以使用 **u, g, o** 来代表三种身份的权限。此外， **a** 则代表 **all**，即全部的身份。读写的权限可以写成 **r, w, x**

```bash
#将文件权限设置为 -rwxr-xr--
#+(加入)-(除去)=(设定)
chmod u=rwx,g=rx,o=r 文件名
```

### Linux文件与目录管理

##### pwd (显示目前所在的目录)

- **-P** ：显示出确实的路径，而非使用连结 (link) 路径。

##### Linux 文件内容查看

- cat 由第一行开始显示文件内容
- tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
- nl  显示的时候，顺道输出行号！
- more 一页一页的显示文件内容
- less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行

##### Linux 链接概念

**硬连接**

硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。

硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。

**软连接**

另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。

```bash
[oracle@Linux]$ ln f1 f2          #创建f1的一个硬连接文件f2
[oracle@Linux]$ ln -s f1 f3       #创建f1的一个符号连接文件f3
```

### Linux 用户和用户组管理

##### 与用户账号有关的系统文件

```bash
#/etc/passwd
#用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
root:x:0:0:Superuser:/:
daemon:x:1:1:System daemons:/etc:
bin:x:2:2:Owner of system commands:/bin:
```

现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中

```bash
#/etc/shadow
#登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
root:$6$P78Ogd7k$.3xE3YO1l.dgxLpfOiOft96MIR0lu67UjOhk29C5CTt.RDnfgs/GsCExBKA7IeWnGfRgoKW6Igp0idpTTiaih0:18500:0:99999:7:::
bin:*:17834:0:99999:7:::
daemon:*:17834:0:99999:7:::
```

1. "登录名"是与/etc/passwd文件中的登录名相一致的用户账号
2. "口令"字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。
3. "最后一次修改时间"表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。
4. "最小时间间隔"指的是两次修改口令之间所需的最小天数。
5. "最大时间间隔"指的是口令保持有效的最大天数。
6. "警告时间"字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。
7. "不活动时间"表示的是用户没有登录活动但账号仍能保持有效的最大天数。
8. "失效时间"字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。

```bash
#/etc/group
#组名:口令:组标识号:组内用户列表
root:x:0:
bin:x:1:
daemon:x:2:
```

### Linux 磁盘管理

- df：列出文件系统的整体磁盘使用量

- du：检查磁盘空间使用量
- fdisk：用于磁盘分区

**df**

- -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；
- -k ：以 KBytes 的容量显示各文件系统；
- -m ：以 MBytes 的容量显示各文件系统；
- -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；
- -H ：以 M=1000K 取代 M=1024K 的进位方式；
- -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；
- -i ：不用硬盘容量，而以 inode 的数量来显示

**du**

与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看

- -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。
- -h ：以人们较易读的容量格式 (G/M) 显示；
- -s ：列出总量而已，而不列出每个各别的目录占用容量；
- -S ：不包括子目录下的总计，与 -s 有点差别。
- -k ：以 KBytes 列出容量显示；
- -m ：以 MBytes 列出容量显示；

**fdisk**

- -l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。

# Shell教程

### Shell变量

```bash
your_name="runoob.com"
#用语句给变量赋值
for file in `ls /etc`
或
for file in $(ls /etc)
#使用变量
echo $your_name
echo ${your_name}
#设置只读变量
readonly your_name
#删除变量 unset 命令不能删除只读变量。
unset your_name
```

变量名和等号之间不能有空格

**变量类型**

- **1) 局部变量** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
- **2) 环境变量** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
- **3) shell变量** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

#### shell字符串

单引号：

- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
- 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

双引号：

- 双引号里可以有变量
- 双引号里可以出现转义字符

```bash
your_name="runoob"
# 使用双引号拼接
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1
# 使用单引号拼接
greeting_2='hello, '$your_name' !' #意为'hello, '+$your_name+' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
---
hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !

#获取字符串长度
string="abcd"
echo ${#string}
#提取子字符串
string="runoob is a great site"
echo ${string:1:4} # 从字符串第 2 个字符开始截取 4 个字符 输出 unoo
#查找子字符串
string="runoob is a great site"
echo `expr index "$string" io`  #查找字符 i 或 o 的位置(哪个字母先出现就计算哪个) 输出 4
```

#### Shell数组

bash支持一维数组（不支持多维数组），并且没有限定数组的大小

```bash
#定义数组
数组名=(值1 值2 ... 值n)
#读取数组
${数组名[下标]}
#使用 @ 符号可以获取数组中的所有元素
echo ${array_name[@]}
#获取数组的长度
length=${#array_name[@]}
length=${#array_name[*]}
```

#### 字符截取

**#**、**##** 表示从左边开始删除。一个 **#** 表示从左边删除到第一个指定的字符；两个 **#** 表示从左边删除到最后一个指定的字符。

**%**、**%%** 表示从右边开始删除。一个 **%** 表示从右边删除到第一个指定的字符；两个 **%** 表示从左边删除到最后一个指定的字符。

```bash
var=http://www.aaa.com/123.htm
echo ${var#*//}
>>>www.aaa.com/123.htm
echo ${var##*/}
>>>123.htm
echo ${var%/*}
>>>http://www.aaa.com
echo ${var%%/*}
>>>http:
#从左边第几个字符开始，及字符的个数
echo ${var:0:5}
>>>http:
#从左边第几个字符开始，一直到结束。
echo ${var:7}
>>>www.aaa.com/123.htm
#从右边第几个字符开始，及字符的个数
echo ${var:0-7:3}
>>>123
#从右边第几个字符开始，一直到结束。
echo ${var:0-7}
>>>123.htm
```

### Shell 传递参数

在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n**，**n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……

其中 **$0** 为执行的文件名（包含文件路径）

| 参数处理 | 说明                                                         |
| :------- | :----------------------------------------------------------- |
| $#       | 传递到脚本的参数个数                                         |
| $*       | 以一个单字符串显示所有向脚本传递的参数。 如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。 |
| $$       | 脚本运行的当前进程ID号                                       |
| $!       | 后台运行的最后一个进程的ID号                                 |
| $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 |
| $-       | 显示Shell使用的当前选项，与[set命令](https://www.runoob.com/linux/linux-comm-set.html)功能相同。 |
| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

$* 与 $@ 区别：

只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。