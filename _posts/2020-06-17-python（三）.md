---
title: Python(三)
tag: python
---

### 八、IO编程

#### 文件读写

##### 读文件

```python
try:
    # errors='ignore'表示遇到编码问题直接忽略
    f = open('text.txt', 'r', encoding='UTF-8', errors='ignore')
    print(f.read())
finally:
    f.close()
```

每次都这么写实在太繁琐，所以，Python引入了`with`语句来自动帮我们调用`close()`方法

```python
#不必调用close()
with open('text.txt', 'r', encoding='UTF-8') as f:
    print(f.read(8))
```

调用`read()`会一次性读取文件的全部内容，为了防止文件过大，内存爆炸，可以反复调用`read(size)`方法，每次最多读取size个字节的内容；

调用`readline()`可以每次读取一行内容，调用`readlines()`一次读取所有内容并按行返回`list`

```python
#读取二进制文件，比如图片、视频等
with open('text.txt', 'rb') as f:
    print(f.read())
```

##### 写文件

```python
with open('text.txt', 'w') as f:
    f.write('Hello, world!')
with open('text.txt', 'a') as f:
    f.write('Hello, world!')
```

以`'w'`模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件），可以传入`'a'`以追加（append）模式写入

| 字符  | 含义                                         |
| :---- | :------------------------------------------- |
| `'r'` | 打开以供阅读（默认）                         |
| `'w'` | 打开进行写入，先截断文件                     |
| `'x'` | 打开以进行独占创建，如果文件已经存在，则失败 |
| `'a'` | 打开进行写入，如果存在则追加到文件末尾       |
| `'b'` | 二进制模式                                   |
| `'t'` | 文字模式（默认）                             |
| `'+'` | 开放进行更新（读写）                         |

```python
#a+读写模式，且指针在文件末尾，所以直接读没有内容
with open('text.txt', 'a+', encoding='UTF-8') as f:
    f.write('Hello, world!')
    #读之前将指针重置为文件头
    f.seek(0)
    print(f.read())
```

#### StringIO和BytesIO

##### StringIO

StringIO顾名思义就是在内存中读写str

```python
from io import StringIO

f = StringIO()
#返回写入字符数
f.write('hello ')
f.write('world')
print(f.getvalue())
```

要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取

```python
f = StringIO('Hello!\nHi!\nGoodbye!')
while True:
    s = f.readline()
    if s == '':
        break
    print(s.strip())
```

##### BytesIO

如果要操作二进制数据，就需要使用BytesIO

```python
f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
print(f.read())
```

指针问题

```python
f=StringIO('abc')
f.read() #返回'abc'
f.read() #返回'' 因为使用过一次read之后指针会发生移动
f.getvalue() #返回'abc' 因为getvalue不受指针影响

f=StringIO('')
f.write('abc')
f.read() #返回'' 因为write已经使指针发生了移动
f.getvalue() #返回'abc' 因为getvalue不受指针影响
f.seek(0) #解决方法：用seek将指针归零
f.read() #返回'abc'
f.tell() #返回指针所在位置
```

#### 操作文件和目录

Python内置的`os`模块可以直接调用操作系统提供的接口函数

```python
import os

print(os.name)
#如果是posix，说明系统是Linux、Unix或Mac OS X，如果是nt，就是Windows系统
>>>nt
#获取详细的系统信息，但在Windows上不提供
print(os.uname())
#获取操作系统中定义的环境变量
print(os.environ.get('PATH'))
```

操作文件和目录的函数一部分放在`os`模块中，一部分放在`os.path`模块中

```python
import os

#查看当前目录的绝对路径
print(os.path.abspath('.'))
#在某个目录下创建一个新目录
#首先进行路径拼接
print(os.path.join('.', 'testdir'))
#然后创建目录
os.mkdir(r'.\testdir')
#删除目录
os.rmdir(r'.\testdir')
#把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名
print(os.path.split(r'.\testdir'))
#获得文件的扩展名
print(os.path.splitext(r'.\text.txt'))
#重命名
os.rename('test.txt', 'test.py')
#删除文件
os.remove('test.py')
```

合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作

os模块不存在复制文件函数，原因是复制文件并非由操作系统提供的系统调用；我们可以使用`shutil`模块提供的`copyfile()`的函数

```python
import shutil

shutil.copyfile(r'.\text.txt', r'.\text2.txt')
```

一句代码列出当前目录下的所有目录

```python
print([x for x in os.listdir('.') if os.path.isdir(x)])
```

一句代码列出所有的`.py`文件

```python
print([x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1] == '.py'])
```

#### 序列化

把变量从内存中变成可存储或传输的过程称之为序列化；

序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上；

```python
import pickle

d = dict(name='Bob', age=20, score=88)
#pickle.dumps()方法把任意对象序列化成一个bytes
print(pickle.dumps(d))
#写入文件
with open('dump.txt', 'wb+') as f:
    #直接把对象序列化后写入一个file-like Object
    pickle.dump(d, f)
    f.seek(0)
    #pickle.load()反序列化
    print(pickle.load(f))
```

**pickle只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系**

#### JSON

如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。

```python
import json

d = dict(name='Bob', age=20, score=88)
json_str = json.dumps(d)
print(json_str)
print(json.loads(json_str))
```

`dumps()`方法返回一个`str`，内容就是标准的JSON。类似的，`dump()`方法可以直接把JSON写入一个`file-like Object`;

用`loads()`或者对应的`load()`方法，前者把JSON的字符串反序列化，后者从`file-like Object`中读取字符串并反序列化;

类的实例无法直接序列化为JSON

```python
class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

s = Student('Bob', 20, 88)
print(json.dumps(s))
>>>TypeError: Object of type Student is not JSON serializable
#自定义一个转换函数，缺点就是每个类都需要特殊定制
def studentdict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
print(json.dumps(s, default=studentdict))
#把任意class的实例变为dict
json_str = json.dumps(s, default=lambda obj: obj.__dict__)
print(json_str)

#反序列化
def dictstudent(d):
    return Student(d['name'], d['age'], d['score'])
print(json.loads(json_str, object_hook=dictstudent))
```

### 九、进程和线程

#### multiprocessing

```python
from multiprocessing import Process
import os

def run_proc(name):
    print('Run child process %s (%s)...' % (name, os.getpid()))

if __name__ == '__main__':
    print('Parent process %s:' % os.getpid())
    #创建子进程，target：执行函数，args：参数
    p = Process(target=run_proc, args=('test',))
    print('Child process will start.')
    #启动子进程
    p.start()
    #等待子进程结束后再继续往下运行，通常用于进程间的同步
    p.join()
    print('Child process end.')
```

#### Pool

要启动大量的子进程，可以用进程池的方式批量创建子进程

```python
from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print('Run task %s (%s)...' % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print('Task %s runs %0.2f seconds' % (name, (end - start)))

if __name__ == '__main__':
    print('Parent process %s:' % os.getpid())
    #创建进程池
    p = Pool(4)
    for i in range(5):
        #添加进程，apply_async：异步非阻塞式（需要join函数来等待子进程运行完毕，否则主进程直接结束），					 apply：阻塞式（一个子进程运行完才运行下一个，不需要join函数）
        p.apply_async(long_time_task, args=(i,))
    print('Waiting for all subprocesses done...')
    #关闭进程池，不能再添加进程
    p.close()
    #等待所有子进程执行完毕
    p.join()
    print('All subprocesses done.')
```