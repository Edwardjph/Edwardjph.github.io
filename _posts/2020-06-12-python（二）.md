---
title: Python(二)
tag: python
---

### 五、面向对象编程

#### 类和实例

面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。

面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

定义类

```python
#通过class关键字定义类，object表示继承object类
class Student(object):
    pass

bart = Student()
#可以自由的给变量绑定属性，即使没有定义，神奇！
bart.name = 'Bart'
print(bart.name)
```

```python
class Student2(object):
	#self相当于java的this
    def __init__(self, name, score):
        self.name = name
        self.score = score
    #数据封装 
    def print_score(self):
        print('%s: %s' % (self.name, self.score))
#不能再传空参了
bart = Student2('Bart', 59)
print(bart.name, bart.score)  
bart.print_score()
```

#### 访问限制

```python
class Student3(object):
    
    def __init__(self, name, score):
        self.__name = name
        self.__score = score
        
    def print_score(self):
        print('%s, %s' % (self.__name, self.__score))
        
    def get_name(self):
        return self.__name
    
    def set_name(self, name):
        self.__name = name
        
bart3 = Student3('Bart3', 60)
print(bart3._Student3__name)
bart3.__name = 'New Name' # 没有报错，看似设置成功，其实只是设置了一个新的叫__name的变量
print(bart3.__name)
>>>'New Name'
```

- `__name__`：是特殊变量，不能使用这样的变量名
- `_name`：这样的变量外部是可以访问的，但是，按照约定这样的变量应该视为私有变量，不随意访问
- `__name`：私有变量，但外部其实还是可以访问，只是Python解释器对外把`__name`变量改成了`_Classname__name`，所以可以通过访问`_Classname__name`来访问`__name`

#### 继承和多态

```python
class Animal(object):

    def run(self):
        print('Animal is running...')
#继承        
class Dog(Animal):

    def run(self):
        print('Dog is running...')
        
class Cat(Animal):

    def run(self):
        print('Cat is running...')
        
def run_twice(animal):
    animal.run()

#多态
run_twice(Animal())
run_twice(Cat())
run_twice(Dog())

class Timer(object):
    def run(self):
        print('Start...')
#由于python是动态语言，不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了        
run_twice(Timer())
```

#### 获取对象信息

使用`type()`判断对象类型

```python
import types

print(type(bart))
#判断对象是否是一个函数
print(type(abs) == types.BuiltinFunctionType)
print(type(lambda x: x) == types.LambdaType)
```

使用isinstance()判断class类型

```python
dog = Dog()
print(isinstance(dog, Animal))
#判断该变量是不是list, tuple中的一种
print(isinstance([1, 2, 3], (list, tuple)))
```

使用dir()获得一个对象的所有属性和方法

```python
print(dir('ABC'))
>>>['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
```

配合`getattr()`、`setattr()`以及`hasattr()`，我们可以直接操作一个对象的状态

```python
#有属性name吗，也可以判断方法是否存在
print(hasattr(bart, 'name'))
#设置一个属性age
setattr(bart, 'age', 9)
#获取属性age，也可以获取方法
print(getattr(bart, 'age'))
#如果属性不存在则输出404
print(getattr(bart, 'a', 404))
```

#### 实例属性和类属性

```python
class Student4(object):
    name = 'Student'

s = Student4()
#实例没有name属性，自动找到了类属性name
print(s.name)
>>>Student
#类属性可以直接通过类调用
print(Student4.name)
>>>Student
s.name = 'bart'
#实例属性优先级比类属性高
print(s.name)
>>>bart
#删除实例属性
del s.name
print(s.name)
>>>Student
```

### 六、面向对象高级编程